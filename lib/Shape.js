// Generated by CoffeeScript 1.6.3
(function() {
  var Node, geometry, mapUtils;

  Node = (require("./Node")).Node;

  mapUtils = require("./mapUtils");

  geometry = require("./geometry");

  exports.Shape = (function() {
    function Shape(id, link, name, val) {
      var pair;
      this.id = id;
      this.link = link;
      this.name = name;
      this.val = val;
      this.link = encodeURI(this.link);
      this.name = mapUtils.toHTML(this.name);
      this.coordinates = [];
      this.d = "";
      pair = "\[[0-9]{1,5}(\.[0-9]{1,5})?,[0-9]{1,5}(\.[0-9]{1,5})?\]";
      this.regexes = {
        arc: new RegExp("^arc\[" + pair + "," + pair + "," + pair + "\]$"),
        pie: new RegExp("^pie\[" + pair + "," + pair + "," + pair + "\]$")
      };
    }

    Shape.prototype.firstInstruction = function() {
      if (this.coordinates.length === 0) {
        return "M ";
      } else {
        return "L ";
      }
    };

    Shape.prototype.addVector = function(vector, dx, dy) {
      if (this.regexes.arc.test(vector)) {
        this.addArc(vector.slice(3), dx, dy);
      } else if (this.regexes.pie.test(vector)) {
        this.addPie(vector.slice(3), dx, dy);
      } else {
        this.addPoint(vector, dx, dy);
      }
      return this;
    };

    Shape.prototype.addPoint = function(vector, dx, dy) {
      var err, x, y, _ref, _ref1;
      try {
        _ref = JSON.parse(vector), x = _ref[0], y = _ref[1];
        _ref1 = [x + dx, y + dy], x = _ref1[0], y = _ref1[1];
        this.d += this.firstInstruction() + x + " " + y + " ";
        this.coordinates.push([x, y]);
      } catch (_error) {
        err = _error;
        console.log("Can't parse " + vector);
      }
      return this;
    };

    Shape.prototype.addArc = function(vector, dx, dy) {
      var angle, err, r1, r2, sweep, xa, xb, xc, xcenter, ya, yb, yc, ycenter, _ref, _ref1, _ref2, _ref3, _ref4;
      try {
        _ref = (JSON.parse(vector)).map(function(_arg) {
          var x, y;
          x = _arg[0], y = _arg[1];
          return [x + dx, y + dy];
        }), (_ref1 = _ref[0], xa = _ref1[0], ya = _ref1[1]), (_ref2 = _ref[1], xb = _ref2[0], yb = _ref2[1]), (_ref3 = _ref[2], xc = _ref3[0], yc = _ref3[1]);
        try {
          _ref4 = geometry.calculateEllipse(xa, ya, xb, yb, xc, yc), r1 = _ref4.r1, r2 = _ref4.r2, xcenter = _ref4.xcenter, ycenter = _ref4.ycenter, angle = _ref4.angle, sweep = _ref4.sweep;
          this.d += this.firstInstruction() + xa + " " + ya + " A " + r1 + " " + r2 + " " + (-angle) + " 0 " + sweep + " " + xb + " " + yb + " ";
        } catch (_error) {
          err = _error;
          this.d += this.firstInstruction() + xa + " " + ya + " L " + xc + " " + yc + " L " + xb + " " + yb;
        }
        this.coordinates.push([xa, ya], [xb, yb]);
      } catch (_error) {
        err = _error;
        console.log("Can't parse " + vector);
      }
      return this;
    };

    Shape.prototype.addPie = function(vector, dx, dy) {
      var err, large, r, xa, xb, xc, ya, yb, yc, _ref, _ref1, _ref2, _ref3, _ref4;
      try {
        _ref = (JSON.parse(vector)).map(function(_arg) {
          var x, y;
          x = _arg[0], y = _arg[1];
          return [x + dx, y + dy];
        }), (_ref1 = _ref[0], xa = _ref1[0], ya = _ref1[1]), (_ref2 = _ref[1], xb = _ref2[0], yb = _ref2[1]), (_ref3 = _ref[2], xc = _ref3[0], yc = _ref3[1]);
        _ref4 = geometry.calculatePie(xa, ya, xb, yb, xc, yc), r = _ref4.r, large = _ref4.large;
        this.d += this.firstInstruction() + xa + " " + ya + " A " + r + " " + r + " 0 " + large + " 1 " + xb + " " + yb + " ";
        this.coordinates.push([xa, ya], [xb, yb], [xc, yc]);
      } catch (_error) {
        err = _error;
        console.log("Can't parse " + vector);
      }
      return this;
    };

    Shape.prototype.findCenter = function() {
      var avgx, avgy;
      avgx = geometry.avg([this.coordinates[this.coordinates.length - 1][0], this.coordinates[0][0], this.coordinates[1][0]]);
      avgy = geometry.avg([this.coordinates[this.coordinates.length - 1][1], this.coordinates[0][1], this.coordinates[1][1]]);
      return [avgx, avgy];
    };

    Shape.prototype.createFilter = function(stroke, radialColor) {
      var filter, innerFilter1, innerFilter2;
      filter = new Node(null, "radialGradient");
      innerFilter1 = new Node(filter, "stop");
      innerFilter1.setAttributes({
        offset: "35%",
        "stop-color": radialColor,
        "class": "stop1"
      });
      innerFilter2 = new Node(filter, "stop");
      innerFilter2.setAttributes({
        offset: "99%",
        "stop-color": stroke,
        "class": "stop2"
      });
      return filter;
    };

    Shape.prototype.addToSVG = function(svg, config) {
      var alternateColor, alternateFilter, colors, filter, id, initialColor, initialFilter, node, radialGradient, stroke, value, x, y, _ref, _ref1, _ref2;
      node = new Node(svg, "path");
      node.setAttributes({
        id: this.id,
        name: this.name,
        link: this.link,
        d: this.d + "Z"
      });
      if ((this.val != null) && this.val !== "" && (config.threshold != null) && config.threshold !== "" && ((0 <= (_ref = this.val) && _ref <= 100)) && ((0 <= (_ref1 = config.threshold) && _ref1 <= 100))) {
        colors = {
          green: mapUtils.getColor((this.val - config.threshold) / (100 - config.threshold) * 100, "green", false),
          blue: mapUtils.getColor((this.val - config.threshold) / (100 - config.threshold) * 100, "blue", false),
          red: mapUtils.getColor(this.val / config.threshold * 100, "red", true)
        };
        if (this.val > 70) {
          node.setAttributes({
            "class": "zone good"
          });
          initialColor = colors[config.scale.initial];
          alternateColor = colors[config.scale.alternate];
          stroke = initialColor;
          radialGradient = stroke;
          initialFilter = svg.addDef(this.createFilter(initialColor, initialColor), this.id + "initial");
          alternateFilter = svg.addDef(this.createFilter(alternateColor, alternateColor), this.id + "alternate");
          node.setAttributes({
            "fill": "url(#" + initialFilter + ")",
            initialFilter: initialFilter,
            alternateFilter: alternateFilter,
            initialColor: initialColor,
            alternateColor: alternateColor
          });
        } else {
          node.setAttributes({
            "class": "zone bad"
          });
          stroke = colors.red;
          radialGradient = stroke;
          filter = svg.addDef(this.createFilter(colors.red, colors.red), this.id + "initial");
          node.setAttributes({
            fill: "url(#" + filter + ")"
          });
        }
        value = this.val + "%";
      } else {
        stroke = "#FFFFFF";
        value = "--";
        node.setAttributes({
          fill: "url(#fdashed)",
          "class": "zone"
        });
      }
      node.setAttributes({
        value: value,
        stroke: stroke
      });
      node.setAttributes({
        onmouseover: "mapReporting.shapeOver(evt);",
        onmouseout: "mapReporting.shapeOut(evt);",
        onmousedown: "mapReporting.shapeDown(evt);"
      });
      if (config.showIDs) {
        _ref2 = this.findCenter(), x = _ref2[0], y = _ref2[1];
        y += 20;
        id = new Node(svg, "text", this.id);
        id.setAttributes({
          id: "id" + this.id,
          x: x,
          y: y,
          "class": "zoneid",
          onmouseover: "mapReporting.IDover(evt);",
          onmouseout: "mapReporting.IDout(evt);",
          onmousedown: "mapReporting.IDdown(evt);"
        });
      }
      return this;
    };

    return Shape;

  })();

}).call(this);
