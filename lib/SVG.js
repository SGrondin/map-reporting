// Generated by CoffeeScript 1.6.3
(function() {
  var Node, SVG, Shape, geometry, mapUtils, scores;

  mapUtils = require("./mapUtils.coffee");

  geometry = require("./geometry.coffee");

  SVG = (function() {
    function SVG() {
      this.head = new Node(null, "svg");
      this.head.setAttributes({
        id: "head",
        version: "1.1",
        baseProfile: "full",
        xmlns: "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink"
      });
      this.defs = new Node(this.head, "defs");
      this.nbFilters = 0;
    }

    SVG.prototype.addDef = function(def, id) {
      def.setAttributes({
        "id": "f" + id
      });
      def.setParent(this.defs);
      return "f" + id;
    };

    SVG.prototype.setEmbeddedJS = function(js) {
      var embedded;
      embedded = new Node(this.head, "script", js);
      return embedded.setAttributes({
        "type": "text/javascript"
      });
    };

    SVG.prototype._addChild = function(obj) {
      this.head._addChild(obj);
      return this;
    };

    SVG.prototype.setAttributes = function(obj) {
      var k, v;
      for (k in obj) {
        v = obj[k];
        this.head.attributes[k] = v;
      }
      return this;
    };

    SVG.prototype.toString = function() {
      return "<?xml version=\"1.0\" standalone=\"no\"?>\n" + this.head.toString(0);
    };

    return SVG;

  })();

  Node = (function() {
    function Node(parent, type, inner) {
      var _ref;
      this.parent = parent;
      this.type = type;
      this.inner = inner != null ? inner : "";
      this.children = [];
      this.attributes = {};
      if ((_ref = this.parent) != null) {
        _ref._addChild(this);
      }
    }

    Node.prototype.setParent = function(obj) {
      if (this.parent == null) {
        this.parent = obj;
        this.parent._addChild(this);
      }
      return this;
    };

    Node.prototype._addChild = function(obj) {
      this.children.push(obj);
      return this;
    };

    Node.prototype.setInner = function(inner) {
      this.inner = inner;
      return this;
    };

    Node.prototype.setAttributes = function(obj) {
      var k, v;
      for (k in obj) {
        v = obj[k];
        this.attributes[k] = v;
      }
      return this;
    };

    Node.prototype.toString = function(indent) {
      var k, node, ret, v;
      if (indent == null) {
        indent = 0;
      }
      ret = mapUtils.strRepeat("\t", indent) + "<" + this.type + ((function() {
        var _ref, _results;
        _ref = this.attributes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          _results.push(" " + k + "=\"" + v + "\"");
        }
        return _results;
      }).call(this)).join("");
      if (this.inner.length > 0 || this.children.length > 0) {
        return ret += ">" + this.inner + ((function() {
          var _i, _len, _ref, _results;
          _ref = this.children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            node = _ref[_i];
            _results.push("\n" + node.toString(indent + 1));
          }
          return _results;
        }).call(this)).join("") + "\n" + mapUtils.strRepeat("\t", indent) + "</" + this.type + ">";
      } else {
        return ret += " />";
      }
    };

    return Node;

  })();

  scores = [0.29, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95].reverse();

  Shape = (function() {
    function Shape(id, link, name) {
      var pair;
      this.id = id;
      this.link = link;
      this.name = name;
      this.link = encodeURI(this.link);
      this.name = mapUtils.toHTML(this.name);
      this.coordinates = [];
      this.d = "";
      pair = "\[[0-9]{1,5}(\.[0-9]{1,5})?,[0-9]{1,5}(\.[0-9]{1,5})?\]";
      this.regexes = {
        arc: new RegExp("^arc\[" + pair + "," + pair + "," + pair + "\]$"),
        pie: new RegExp("^pie\[" + pair + "," + pair + "," + pair + "\]$")
      };
    }

    Shape.prototype.firstInstruction = function() {
      if (this.coordinates.length === 0) {
        return "M ";
      } else {
        return "L ";
      }
    };

    Shape.prototype.addVector = function(vector, dx, dy) {
      if (this.regexes.arc.test(vector)) {
        this.addArc(vector.slice(3), dx, dy);
      } else if (this.regexes.pie.test(vector)) {
        this.addPie(vector.slice(3), dx, dy);
      } else {
        this.addPoint(vector, dx, dy);
      }
      return this;
    };

    Shape.prototype.addPoint = function(vector, dx, dy) {
      var err, x, y, _ref, _ref1;
      try {
        _ref = JSON.parse(vector), x = _ref[0], y = _ref[1];
        _ref1 = [x + dx, y + dy], x = _ref1[0], y = _ref1[1];
        this.d += this.firstInstruction() + x + " " + y + " ";
        this.coordinates.push([x, y]);
      } catch (_error) {
        err = _error;
        console.log("Can't parse " + vector);
      }
      return this;
    };

    Shape.prototype.addArc = function(vector, dx, dy) {
      var angle, err, r1, r2, sweep, xa, xb, xc, xcenter, ya, yb, yc, ycenter, _ref, _ref1, _ref2, _ref3, _ref4;
      try {
        _ref = (JSON.parse(vector)).map(function(_arg) {
          var x, y;
          x = _arg[0], y = _arg[1];
          return [x + dx, y + dy];
        }), (_ref1 = _ref[0], xa = _ref1[0], ya = _ref1[1]), (_ref2 = _ref[1], xb = _ref2[0], yb = _ref2[1]), (_ref3 = _ref[2], xc = _ref3[0], yc = _ref3[1]);
        try {
          _ref4 = geometry.calculateEllipse(xa, ya, xb, yb, xc, yc), r1 = _ref4.r1, r2 = _ref4.r2, xcenter = _ref4.xcenter, ycenter = _ref4.ycenter, angle = _ref4.angle, sweep = _ref4.sweep;
          this.d += this.firstInstruction() + xa + " " + ya + " A " + r1 + " " + r2 + " " + (-angle) + " 0 " + sweep + " " + xb + " " + yb + " ";
        } catch (_error) {
          err = _error;
          this.d += this.firstInstruction() + xa + " " + ya + " L " + xc + " " + yc + " L " + xb + " " + yb;
        }
        this.coordinates.push([xa, ya], [xb, yb]);
      } catch (_error) {
        err = _error;
        console.log("Can't parse " + vector);
      }
      return this;
    };

    Shape.prototype.addPie = function(vector, dx, dy) {
      var err, large, r, xa, xb, xc, ya, yb, yc, _ref, _ref1, _ref2, _ref3, _ref4;
      try {
        _ref = (JSON.parse(vector)).map(function(_arg) {
          var x, y;
          x = _arg[0], y = _arg[1];
          return [x + dx, y + dy];
        }), (_ref1 = _ref[0], xa = _ref1[0], ya = _ref1[1]), (_ref2 = _ref[1], xb = _ref2[0], yb = _ref2[1]), (_ref3 = _ref[2], xc = _ref3[0], yc = _ref3[1]);
        _ref4 = geometry.calculatePie(xa, ya, xb, yb, xc, yc), r = _ref4.r, large = _ref4.large;
        this.d += this.firstInstruction() + xa + " " + ya + " A " + r + " " + r + " 0 " + large + " 1 " + xb + " " + yb + " ";
        this.coordinates.push([xa, ya], [xb, yb], [xc, yc]);
      } catch (_error) {
        err = _error;
        console.log("Can't parse " + vector);
      }
      return this;
    };

    Shape.prototype.findCenter = function() {
      var avgx, avgy;
      avgx = geometry.avg([this.coordinates[this.coordinates.length - 1][0], this.coordinates[0][0], this.coordinates[1][0]]);
      avgy = geometry.avg([this.coordinates[this.coordinates.length - 1][1], this.coordinates[0][1], this.coordinates[1][1]]);
      return [avgx, avgy];
    };

    Shape.prototype.createFilter = function(stroke, radialColor) {
      var filter, innerFilter1, innerFilter2;
      filter = new Node(null, "radialGradient");
      innerFilter1 = new Node(filter, "stop");
      innerFilter1.setAttributes({
        offset: "35%",
        "stop-color": radialColor,
        "stop-opacity": "0.5"
      });
      innerFilter2 = new Node(filter, "stop");
      innerFilter2.setAttributes({
        offset: "99%",
        "stop-color": stroke,
        "stop-opacity": "0.8"
      });
      return filter;
    };

    Shape.prototype.addToSVG = function(svg, initial, alternate) {
      var alternateColor, alternateFilter, colors, filter, id, initialColor, initialFilter, node, radialColor, radialGradient, score, stroke, val, value, x, y, _ref;
      node = new Node(svg, "path");
      node.setAttributes({
        id: this.id,
        name: this.name,
        link: this.link + this.name,
        d: this.d + "Z"
      });
      score = Math.random();
      if (score >= 0.4) {
        val = score * 100;
        colors = {
          green: mapUtils.getColor((val - 70) / 30 * 100, "green", false),
          blue: mapUtils.getColor((val - 70) / 30 * 100, "blue", false),
          red: mapUtils.getColor((val - 40) / 30 * 100, "red", true)
        };
        if (val > 70) {
          node.setAttributes({
            "class": "good"
          });
          initialColor = colors[initial];
          alternateColor = colors[alternate];
          stroke = initialColor;
          radialGradient = initial;
          initialFilter = svg.addDef(this.createFilter(initialColor, initialColor), this.id + "initial");
          alternateFilter = svg.addDef(this.createFilter(alternateColor, alternateColor), this.id + "alternate");
          node.setAttributes({
            "fill": "url(#" + initialFilter + ")",
            initialFilter: initialFilter,
            alternateFilter: alternateFilter,
            initialColor: initialColor,
            alternateColor: alternateColor
          });
        } else {
          node.setAttributes({
            "class": "bad"
          });
          stroke = colors.red;
          radialGradient = stroke;
          filter = svg.addDef(this.createFilter(colors.red, colors.red), this.id + "initial");
          node.setAttributes({
            fill: "url(#" + filter + ")"
          });
        }
        value = Math.round(score * 100) + "%";
      } else {
        stroke = "#FFFFFF";
        radialColor = "#AAAAAA";
        value = "--";
        node.setAttributes({
          fill: "url(#fdashed)"
        });
      }
      node.setAttributes({
        value: value,
        stroke: stroke,
        "stroke-width": 4,
        "stroke-opacity": "0.4"
      });
      node.setAttributes({
        onmouseover: "mouseOver(evt);",
        onmouseout: "mouseOut(evt);",
        onmousedown: "mouseDown(evt);"
      });
      _ref = this.findCenter(), x = _ref[0], y = _ref[1];
      id = new Node(svg, "text", this.id);
      id.setAttributes({
        id: "id" + this.id,
        x: x,
        y: y,
        "font-family": "Courier",
        "font-size": "32px",
        fill: "#000000",
        stroke: "#000000",
        "stroke-width": 2,
        style: "text-anchor: middle"
      });
      return this;
    };

    return Shape;

  })();

  module.exports = {
    SVG: SVG,
    Node: Node,
    Shape: Shape
  };

}).call(this);
