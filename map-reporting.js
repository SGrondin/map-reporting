;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var mapUtils;

  mapUtils = require("./mapUtils");

  exports.Node = (function() {
    function Node(parent, type, inner, cdata) {
      var _ref;
      this.parent = parent;
      this.type = type;
      this.inner = inner != null ? inner : "";
      this.cdata = cdata != null ? cdata : "";
      this.children = [];
      this.attributes = {};
      if ((_ref = this.parent) != null) {
        _ref._addChild(this);
      }
    }

    Node.prototype.setParent = function(obj) {
      if (this.parent == null) {
        this.parent = obj;
        this.parent._addChild(this);
      }
      return this;
    };

    Node.prototype._addChild = function(obj) {
      this.children.push(obj);
      return this;
    };

    Node.prototype.setInner = function(inner) {
      this.inner = inner;
      return this;
    };

    Node.prototype.setAttributes = function(obj) {
      var k, v;
      for (k in obj) {
        v = obj[k];
        this.attributes[k] = v;
      }
      return this;
    };

    Node.prototype.toString = function(indent) {
      var k, node, ret, v;
      if (indent == null) {
        indent = 0;
      }
      ret = mapUtils.strRepeat("\t", indent) + "<" + this.type + ((function() {
        var _ref, _results;
        _ref = this.attributes;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          _results.push(" " + k + "=\"" + v + "\"");
        }
        return _results;
      }).call(this)).join("");
      if (this.inner.length > 0 || this.cdata.length > 0 || this.children.length > 0) {
        return ret += ">" + this.inner + this.cdata + ((function() {
          var _i, _len, _ref, _results;
          _ref = this.children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            node = _ref[_i];
            _results.push("\n" + node.toString(indent + 1));
          }
          return _results;
        }).call(this)).join("") + "\n" + mapUtils.strRepeat("\t", indent) + "</" + this.type + ">";
      } else {
        return ret += " />";
      }
    };

    Node.prototype.toDOM = function(addTo) {
      var c, el, k, v, _i, _len, _ref, _ref1, _results;
      el = addTo.append(this.type);
      if (this.inner.length > 0) {
        el.text(this.inner);
      }
      _ref = this.attributes;
      for (k in _ref) {
        v = _ref[k];
        if (k.indexOf("xmlns") < 0) {
          el.attr(k, v);
        }
      }
      _ref1 = this.children;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        c = _ref1[_i];
        _results.push(c.toDOM(el));
      }
      return _results;
    };

    return Node;

  })();

}).call(this);

},{"./mapUtils":8}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Node;

  Node = (require("./Node")).Node;

  exports.SVG = (function() {
    function SVG() {
      this.head = new Node(null, "svg");
      this.head.setAttributes({
        id: "head",
        version: "1.1",
        baseProfile: "full",
        xmlns: "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink"
      });
      this.defs = new Node(this.head, "defs");
    }

    SVG.prototype.addDef = function(def, id) {
      def.setAttributes({
        "id": "f" + id
      });
      def.setParent(this.defs);
      return "f" + id;
    };

    SVG.prototype.setEmbeddedJS = function(js) {
      var script;
      script = new Node(this.head, "script", "", js);
      script.setAttributes({
        "type": "text/javascript"
      });
      return this;
    };

    SVG.prototype._addChild = function(obj) {
      this.head._addChild(obj);
      return this;
    };

    SVG.prototype.setAttributes = function(obj) {
      var k, v;
      for (k in obj) {
        v = obj[k];
        this.head.attributes[k] = v;
      }
      return this;
    };

    SVG.prototype.toString = function() {
      return "<?xml version=\"1.0\" standalone=\"no\"?>\n" + this.head.toString(0);
    };

    SVG.prototype.toDOM = function(containerID, d3) {
      var el;
      el = d3.select("#" + containerID);
      this.head.toDOM(el);
      return this;
    };

    return SVG;

  })();

}).call(this);

},{"./Node":1}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Node, geometry, mapUtils;

  Node = (require("./Node")).Node;

  mapUtils = require("./mapUtils");

  geometry = require("./geometry");

  exports.Shape = (function() {
    function Shape(id, link, name, val) {
      var pair;
      this.id = id;
      this.link = link;
      this.name = name;
      this.val = val;
      this.link = encodeURI(this.link);
      this.name = mapUtils.toHTML(this.name);
      this.coordinates = [];
      this.d = "";
      pair = "\[[0-9]{1,5}(\.[0-9]{1,5})?,[0-9]{1,5}(\.[0-9]{1,5})?\]";
      this.regexes = {
        arc: new RegExp("^arc\[" + pair + "," + pair + "," + pair + "\]$"),
        pie: new RegExp("^pie\[" + pair + "," + pair + "," + pair + "\]$")
      };
    }

    Shape.prototype.firstInstruction = function() {
      if (this.coordinates.length === 0) {
        return "M ";
      } else {
        return "L ";
      }
    };

    Shape.prototype.addVector = function(vector, dx, dy) {
      if (this.regexes.arc.test(vector)) {
        this.addArc(vector.slice(3), dx, dy);
      } else if (this.regexes.pie.test(vector)) {
        this.addPie(vector.slice(3), dx, dy);
      } else {
        this.addPoint(vector, dx, dy);
      }
      return this;
    };

    Shape.prototype.addPoint = function(vector, dx, dy) {
      var err, x, y, _ref, _ref1;
      try {
        _ref = JSON.parse(vector), x = _ref[0], y = _ref[1];
        _ref1 = [x + dx, y + dy], x = _ref1[0], y = _ref1[1];
        this.d += this.firstInstruction() + x + " " + y + " ";
        this.coordinates.push([x, y]);
      } catch (_error) {
        err = _error;
        console.log("Can't parse " + vector);
      }
      return this;
    };

    Shape.prototype.addArc = function(vector, dx, dy) {
      var angle, err, r1, r2, sweep, xa, xb, xc, xcenter, ya, yb, yc, ycenter, _ref, _ref1, _ref2, _ref3, _ref4;
      try {
        _ref = (JSON.parse(vector)).map(function(_arg) {
          var x, y;
          x = _arg[0], y = _arg[1];
          return [x + dx, y + dy];
        }), (_ref1 = _ref[0], xa = _ref1[0], ya = _ref1[1]), (_ref2 = _ref[1], xb = _ref2[0], yb = _ref2[1]), (_ref3 = _ref[2], xc = _ref3[0], yc = _ref3[1]);
        try {
          _ref4 = geometry.calculateEllipse(xa, ya, xb, yb, xc, yc), r1 = _ref4.r1, r2 = _ref4.r2, xcenter = _ref4.xcenter, ycenter = _ref4.ycenter, angle = _ref4.angle, sweep = _ref4.sweep;
          this.d += this.firstInstruction() + xa + " " + ya + " A " + r1 + " " + r2 + " " + (-angle) + " 0 " + sweep + " " + xb + " " + yb + " ";
        } catch (_error) {
          err = _error;
          this.d += this.firstInstruction() + xa + " " + ya + " L " + xc + " " + yc + " L " + xb + " " + yb;
        }
        this.coordinates.push([xa, ya], [xb, yb]);
      } catch (_error) {
        err = _error;
        console.log("Can't parse " + vector);
      }
      return this;
    };

    Shape.prototype.addPie = function(vector, dx, dy) {
      var err, large, r, xa, xb, xc, ya, yb, yc, _ref, _ref1, _ref2, _ref3, _ref4;
      try {
        _ref = (JSON.parse(vector)).map(function(_arg) {
          var x, y;
          x = _arg[0], y = _arg[1];
          return [x + dx, y + dy];
        }), (_ref1 = _ref[0], xa = _ref1[0], ya = _ref1[1]), (_ref2 = _ref[1], xb = _ref2[0], yb = _ref2[1]), (_ref3 = _ref[2], xc = _ref3[0], yc = _ref3[1]);
        _ref4 = geometry.calculatePie(xa, ya, xb, yb, xc, yc), r = _ref4.r, large = _ref4.large;
        this.d += this.firstInstruction() + xa + " " + ya + " A " + r + " " + r + " 0 " + large + " 1 " + xb + " " + yb + " ";
        this.coordinates.push([xa, ya], [xb, yb], [xc, yc]);
      } catch (_error) {
        err = _error;
        console.log("Can't parse " + vector);
      }
      return this;
    };

    Shape.prototype.findCenter = function() {
      var avgx, avgy;
      avgx = geometry.avg([this.coordinates[this.coordinates.length - 1][0], this.coordinates[0][0], this.coordinates[1][0]]);
      avgy = geometry.avg([this.coordinates[this.coordinates.length - 1][1], this.coordinates[0][1], this.coordinates[1][1]]);
      return [avgx, avgy];
    };

    Shape.prototype.createFilter = function(stroke, radialColor) {
      var filter, innerFilter1, innerFilter2;
      filter = new Node(null, "radialGradient");
      innerFilter1 = new Node(filter, "stop");
      innerFilter1.setAttributes({
        offset: "35%",
        "stop-color": radialColor,
        "stop-opacity": "0.5"
      });
      innerFilter2 = new Node(filter, "stop");
      innerFilter2.setAttributes({
        offset: "99%",
        "stop-color": stroke,
        "stop-opacity": "0.8"
      });
      return filter;
    };

    Shape.prototype.addToSVG = function(svg, initial, alternate, threshold, IDconfig) {
      var alternateColor, alternateFilter, colors, filter, id, initialColor, initialFilter, node, radialColor, radialGradient, stroke, value, x, y, _ref, _ref1;
      node = new Node(svg, "path");
      node.setAttributes({
        id: this.id,
        name: this.name,
        link: this.link,
        d: this.d + "Z"
      });
      if ((this.val != null) && this.val !== "" && (threshold != null) && threshold !== "" && ((0 <= (_ref = this.val) && _ref <= 100)) && ((0 <= threshold && threshold <= 100))) {
        colors = {
          green: mapUtils.getColor((this.val - threshold) / (100 - threshold) * 100, "green", false),
          blue: mapUtils.getColor((this.val - threshold) / (100 - threshold) * 100, "blue", false),
          red: mapUtils.getColor(this.val / threshold * 100, "red", true)
        };
        if (this.val > 70) {
          node.setAttributes({
            "class": "good"
          });
          initialColor = colors[initial];
          alternateColor = colors[alternate];
          stroke = initialColor;
          radialGradient = stroke;
          initialFilter = svg.addDef(this.createFilter(initialColor, initialColor), this.id + "initial");
          alternateFilter = svg.addDef(this.createFilter(alternateColor, alternateColor), this.id + "alternate");
          node.setAttributes({
            "fill": "url(#" + initialFilter + ")",
            initialFilter: initialFilter,
            alternateFilter: alternateFilter,
            initialColor: initialColor,
            alternateColor: alternateColor
          });
        } else {
          node.setAttributes({
            "class": "bad"
          });
          stroke = colors.red;
          radialGradient = stroke;
          filter = svg.addDef(this.createFilter(colors.red, colors.red), this.id + "initial");
          node.setAttributes({
            fill: "url(#" + filter + ")"
          });
        }
        value = this.val + "%";
      } else {
        stroke = "#FFFFFF";
        radialColor = "#AAAAAA";
        value = "--";
        node.setAttributes({
          fill: "url(#fdashed)"
        });
      }
      node.setAttributes({
        value: value,
        stroke: stroke,
        "stroke-width": 4,
        "stroke-opacity": "0.4"
      });
      node.setAttributes({
        onmouseover: "mapReporting.mouseOver(evt);",
        onmouseout: "mapReporting.mouseOut(evt);",
        onmousedown: "mapReporting.mouseDown(evt);"
      });
      if (IDconfig.show) {
        _ref1 = this.findCenter(), x = _ref1[0], y = _ref1[1];
        id = new Node(svg, "text", this.id);
        id.setAttributes({
          id: "id" + this.id,
          x: x,
          y: y,
          "font-family": "Courier",
          "font-size": "32px",
          fill: IDconfig.color,
          stroke: IDconfig.color,
          "stroke-width": 2,
          style: "text-anchor: bottom"
        });
      }
      return this;
    };

    return Shape;

  })();

}).call(this);

},{"./Node":1,"./geometry":6,"./mapUtils":8}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  exports.getEmbeddedJS = function(labels) {
    var embedded, k, scope, v;
    scope = module.exports.setClientScope({}, labels);
    embedded = "\n<![CDATA[\n";
    embedded += "var scope = mapReporting = {";
    for (k in scope) {
      v = scope[k];
      embedded += "\n" + k + " : ";
      embedded += (v != null) && typeof v === "function" ? v.toString() : (v != null) && typeof v === "object" ? JSON.stringify(v) : null;
      embedded += ",";
    }
    return embedded += "};\n]]>";
  };

  exports.setClientScope = function(scope, labels) {
    scope.usingAlternateColor = false;
    scope.hoveredStroke = null;
    scope.selectedShape = null;
    scope.selectedStroke = null;
    scope.labels = labels;
    scope.displayShapeInDashboard = function(shape) {
      document.getElementById("dashboardTitle").firstChild.nodeValue = shape.getAttribute("id") + " " + shape.getAttribute("name");
      document.getElementById("dashboardLink").setAttribute("xlink:href", shape.getAttribute("link").replace(/&/g, "%26"));
      document.getElementById("dashboardLink").setAttribute("href", shape.getAttribute("link").replace(/&/g, "%26"));
      document.getElementById("dashboardLinkText").firstChild.nodeValue = this.labels.link;
      return document.getElementById("dashboardSatisfaction").firstChild.nodeValue = this.labels.value + shape.getAttribute("value");
    };
    scope.emptyDashboard = function() {
      document.getElementById("dashboardTitle").firstChild.nodeValue = "Nothing selected";
      document.getElementById("dashboardLinkText").firstChild.nodeValue = "";
      return document.getElementById("dashboardSatisfaction").firstChild.nodeValue = "";
    };
    scope.putOnTop = function(shape) {
      var id;
      this.displayShapeInDashboard(shape);
      document.getElementById("head").appendChild(shape);
      id = document.getElementById("id" + shape.getAttribute("id"));
      if (id !== null) {
        return document.getElementById("head").appendChild(id);
      }
    };
    scope.selectShape = function(shape) {
      this.selectedShape = shape;
      this.selectedStroke = this.hoveredStroke;
      shape.setAttribute("stroke", "#000000");
      shape.setAttribute("stroke-opacity", "1");
      shape.setAttribute("stroke-width", "6");
      return shape.removeAttribute("stroke-dasharray");
    };
    scope.releaseShape = function() {
      this.selectedShape.setAttribute("stroke", this.selectedStroke);
      this.selectedShape.setAttribute("stroke-width", "4");
      this.selectedShape.setAttribute("stroke-opacity", "0.4");
      this.selectedStroke = null;
      return this.selectedShape = null;
    };
    scope.mouseOver = function(evt) {
      this.putOnTop(evt.target);
      if (evt.target !== this.selectedShape) {
        this.hoveredStroke = evt.target.getAttribute("stroke");
        evt.target.setAttribute("stroke", "#000000");
        evt.target.setAttribute("stroke-opacity", "1");
        evt.target.setAttribute("stroke-width", "6");
        return evt.target.setAttribute("stroke-dasharray", "12,8");
      }
    };
    scope.mouseOut = function(evt) {
      if (this.selectedShape !== null) {
        this.putOnTop(this.selectedShape);
      } else {
        this.emptyDashboard();
      }
      evt.target.removeAttribute("stroke-dasharray");
      if (evt.target !== this.selectedShape) {
        evt.target.setAttribute("stroke", this.hoveredStroke);
        evt.target.setAttribute("stroke-opacity", "0.4");
        return evt.target.setAttribute("stroke-width", "4");
      }
    };
    scope.mouseDown = function(evt) {
      if (this.selectedShape === null) {
        return this.selectShape(evt.target);
      } else if (evt.target === this.selectedShape) {
        this.hoveredStroke = this.selectedStroke;
        this.selectedStroke = null;
        this.selectedShape = null;
        return evt.target.setAttribute("stroke-dasharray", "12,8");
      } else {
        this.releaseShape();
        return this.selectShape(evt.target);
      }
    };
    scope.changeScaleColor = function(evt) {
      var element, elements, _i, _len;
      elements = document.getElementsByClassName("good");
      for (_i = 0, _len = elements.length; _i < _len; _i++) {
        element = elements[_i];
        if (this.usingAlternateColor) {
          element.setAttribute("fill", "url(#" + element.getAttribute("initialFilter") + ")");
          element.setAttribute("stroke", element.getAttribute("initialColor"));
        } else {
          element.setAttribute("fill", "url(#" + element.getAttribute("alternateFilter") + ")");
          element.setAttribute("stroke", element.getAttribute("alternateColor"));
        }
      }
      return this.usingAlternateColor = !this.usingAlternateColor;
    };
    return scope;
  };

}).call(this);

},{}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Node, SVG, Shape, embeddedJS, mapUtils, shapeFromZone;

  embeddedJS = require("./embeddedJS");

  mapUtils = require("./mapUtils");

  SVG = (require("./SVG")).SVG;

  Node = (require("./Node")).Node;

  Shape = (require("./Shape")).Shape;

  shapeFromZone = function(zone, config) {
    var shape;
    shape = new Shape(zone.ID, zone.link, zone.name, zone.value);
    zone.coordinates.split(";").forEach(function(vector) {
      return shape.addVector(vector, config.background.x, config.background.y);
    });
    return shape;
  };

  exports.generateMap = function(config, zones, image) {
    var alternateColor, bg, d, dashboardLink, dashboardLinkText, dashboardSatisfaction, dashboardTitle, desaturation, desaturationFilter, halfDown, halfUp, i, initialColor, innerPattern, line, pattern, svg, textrectangle, value, zone, _i, _j, _k, _len, _ref;
    svg = new SVG();
    svg.setAttributes({
      width: config.width,
      height: config.height
    });
    svg.setEmbeddedJS(embeddedJS.getEmbeddedJS(config.labels));
    if (image != null) {
      bg = new Node(svg, "image");
      bg.setAttributes({
        "xlink:href": "data:image/png;base64," + image,
        x: config.background.x,
        y: config.background.y,
        height: config.background.height,
        width: config.background.width,
        filter: "url(#fdesaturation)"
      });
    }
    for (_i = 0, _len = zones.length; _i < _len; _i++) {
      zone = zones[_i];
      (shapeFromZone(zone, config)).addToSVG(svg, config.scale.initial, config.scale.alternate, config.threshold, config.IDs);
    }
    pattern = new Node(null, "pattern");
    pattern.setAttributes({
      width: "10",
      height: "10",
      patternUnits: "userSpaceOnUse"
    });
    innerPattern = new Node(pattern, "path");
    innerPattern.setAttributes({
      d: "M 0 10 L 10 0 Z",
      stroke: "#FFFFFF",
      "stroke-opacity": 0.75,
      "stroke-width": 2
    });
    svg.addDef(pattern, "dashed");
    desaturation = new Node(null, "filter");
    desaturation.setAttributes({
      x: 0,
      y: 0
    });
    desaturationFilter = new Node(desaturation, "feColorMatrix");
    desaturationFilter.setAttributes({
      "in": "SourceGraphic",
      type: "saturate",
      values: config.background.saturation
    });
    svg.addDef(desaturation, "desaturation");
    halfUp = Math.floor(config.scale.width / 2);
    halfDown = Math.ceil(config.scale.width / 2);
    for (i = _j = 0; 0 <= halfUp ? _j <= halfUp : _j >= halfUp; i = 0 <= halfUp ? ++_j : --_j) {
      value = i / (config.scale.width / 2 / 100);
      line = new Node(svg, "path");
      line.setAttributes({
        d: "M " + (config.scale.x + i) + " " + (config.scale.y + config.scale.height) + " L " + (config.scale.x + i) + " " + config.scale.y + " Z",
        stroke: mapUtils.getColor(value, "red", true),
        "class": "bad",
        onmousedown: "mapReporting.changeScaleColor(evt);"
      });
    }
    for (i = _k = halfDown, _ref = config.scale.width; halfDown <= _ref ? _k <= _ref : _k >= _ref; i = halfDown <= _ref ? ++_k : --_k) {
      value = (i - halfDown) / (config.scale.width / 2 / 100);
      line = new Node(svg, "path");
      d = "M " + (config.scale.x + i) + " " + (config.scale.y + config.scale.height) + " L " + (config.scale.x + i) + " " + config.scale.y + " Z";
      initialColor = mapUtils.getColor(value, config.scale.initial, false);
      alternateColor = mapUtils.getColor(value, config.scale.alternate, false);
      line.setAttributes({
        d: d,
        stroke: initialColor,
        initialColor: initialColor,
        alternateColor: alternateColor,
        "class": "good",
        onmousedown: "mapReporting.changeScaleColor(evt);"
      });
    }
    textrectangle = new Node(svg, "rect");
    textrectangle.setAttributes({
      x: config.dashboard.x,
      y: config.dashboard.y,
      width: config.dashboard.width,
      height: config.dashboard.height,
      fill: "#FFFFFF",
      "fill-opacity": "0.7"
    });
    dashboardTitle = new Node(svg, "text", "Nothing selected");
    dashboardTitle.setAttributes({
      x: config.dashboard.x + 10,
      y: config.dashboard.y + 16,
      id: "dashboardTitle",
      "font-family": "Arial"
    });
    dashboardLink = new Node(svg, "a");
    dashboardLink.setAttributes({
      "xlink:href": "",
      "href": "",
      id: "dashboardLink",
      target: "_blank"
    });
    dashboardSatisfaction = new Node(svg, "text", " ");
    dashboardSatisfaction.setAttributes({
      x: config.dashboard.x + 10,
      y: config.dashboard.y + 41,
      id: "dashboardSatisfaction",
      "font-family": "Arial"
    });
    dashboardLinkText = new Node(dashboardLink, "text", " ");
    dashboardLinkText.setAttributes({
      x: config.dashboard.x + 10,
      y: config.dashboard.y + 66,
      id: "dashboardLinkText",
      "font-family": "Arial",
      "style": "text-decoration:underline;"
    });
    return svg;
  };

}).call(this);

},{"./Node":1,"./SVG":2,"./Shape":3,"./embeddedJS":4,"./mapUtils":8}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var avg, calculateEllipse, calculatePie, distance, isLeftSide, rotate, sum, toDeg, toRad;

  distance = function(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  };

  rotate = function(x, y, a) {
    return [Math.cos(a) * x - Math.sin(a) * y, Math.sin(a) * x + Math.cos(a) * y];
  };

  isLeftSide = function(xa, ya, xb, yb, xc, yc) {
    return ((xb - xa) * (yc - ya) - (yb - ya) * (xc - xa)) > 0;
  };

  toDeg = function(x) {
    return x * (180 / Math.PI);
  };

  toRad = function(x) {
    return x * (Math.PI / 180);
  };

  sum = function(arr) {
    return arr.reduce(function(a, b) {
      return a + b;
    });
  };

  avg = function(arr) {
    return sum(arr) / arr.length;
  };

  calculateEllipse = function(xa, ya, xb, yb, xc, yc) {
    var angle, opposite, oxa, oxb, oxc, oya, oyb, oyc, r1, r2, sweep, t, u, xcenter, ycenter, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    _ref = [xa, ya, xb, yb, xc, yc], oxa = _ref[0], oya = _ref[1], oxb = _ref[2], oyb = _ref[3], oxc = _ref[4], oyc = _ref[5];
    _ref1 = [(xa + xb) / 2, (ya + yb) / 2], xcenter = _ref1[0], ycenter = _ref1[1];
    r1 = distance(xa, ya, xcenter, ycenter);
    opposite = Math.abs(yb - ycenter);
    angle = Math.asin(opposite / r1);
    _ref2 = [[xa - xcenter, ya - ycenter], [xb - xcenter, yb - ycenter], [xc - xcenter, yc - ycenter]], (_ref3 = _ref2[0], xa = _ref3[0], ya = _ref3[1]), (_ref4 = _ref2[1], xb = _ref4[0], yb = _ref4[1]), (_ref5 = _ref2[2], xc = _ref5[0], yc = _ref5[1]);
    _ref6 = [rotate(xa, ya, angle), rotate(xb, yb, angle), rotate(xc, yc, angle)], (_ref7 = _ref6[0], xa = _ref7[0], ya = _ref7[1]), (_ref8 = _ref6[1], xb = _ref8[0], yb = _ref8[1]), (_ref9 = _ref6[2], xc = _ref9[0], yc = _ref9[1]);
    if (xc > r1) {
      _ref10 = [xc, yc], yc = _ref10[0], xc = _ref10[1];
    }
    t = Math.pow(xc, 2) / Math.pow(r1, 2);
    u = Math.pow(yc, 2);
    r2 = Math.sqrt(u / (1 - t));
    sweep = oya === oyb ? oxc > oxa ? (oyc < oya ? 1 : 0) : (oyc < oya ? 0 : 1) : oxa === oxb ? oya < oyb ? (oxc < oxa ? 0 : 1) : (oxc < oxa ? 1 : 0) : ((xc < 0 && yc < 0) || (xc > 0 && yc > 0) ? 0 : 1);
    return {
      r1: r1,
      r2: r2,
      xcenter: xcenter,
      ycenter: ycenter,
      angle: toDeg(angle),
      sweep: sweep
    };
  };

  calculatePie = function(xa, ya, xb, yb, xc, yc) {
    var large, r;
    large = isLeftSide(xa, ya, xb, yb, xc, yc) ? 0 : 1;
    r = (distance(xa, ya, xc, yc) + distance(xb, yb, xc, yc)) / 2;
    return {
      r: r,
      large: large
    };
  };

  module.exports = {
    calculateEllipse: calculateEllipse,
    calculatePie: calculatePie,
    avg: avg
  };

}).call(this);

},{}],7:[function(require,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};// Generated by CoffeeScript 1.6.3
(function() {
  var embeddedJS;

  exports.generateMap = (require('./generateMap')).generateMap;

  embeddedJS = require('./embeddedJS');

  if (global.window != null) {
    global.window.mapReporting = {
      generateMap: function(config, zones, image) {
        embeddedJS.setClientScope(this, config.labels);
        return module.exports.generateMap(config, zones, image);
      }
    };
  }

}).call(this);

},{"./embeddedJS":4,"./generateMap":5}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var lagrange, lpad;

  exports.strRepeat = function(str, nb) {
    return new Array(nb + 1).join(str);
  };

  lpad = function(str, pad, len) {
    return (str.length < len ? exports.strRepeat(pad, len - str.length) : "") + str;
  };

  exports.toHTML = function(str) {
    return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  };

  lagrange = function(a, b, c, d) {};

  exports.getColor = function(val, color, invert) {
    var b, g, r;
    if (invert == null) {
      invert = false;
    }
    if (invert) {
      val = 100 - val;
    }
    color = color.toLowerCase();
    if (color === "blue") {
      r = -(57 * Math.pow(val, 4) - 12350 * Math.pow(val, 3) + 729375 * Math.pow(val, 2) + 5093750 * val - 1350000000) / 9375000;
      g = -(31 * Math.pow(val, 4) - 6790 * Math.pow(val, 3) + 457625 * Math.pow(val, 2) - 6481250 * val - 403125000) / 1875000;
      b = -(13 * Math.pow(val, 4) - 3190 * Math.pow(val, 3) + 240875 * Math.pow(val, 2) - 4156250 * val - 440625000) / 1875000;
    } else if (color === "red") {
      r = (19 * Math.pow(val, 4) - 4950 * Math.pow(val, 3) + 295625 * Math.pow(val, 2) - 7593750 * val + 2390625000) / 9375000;
      g = (23 * Math.pow(val, 4) - 3350 * Math.pow(val, 3) + 173125 * Math.pow(val, 2) - 18343750 * val + 1546875000) / 9375000;
      b = -(33 * Math.pow(val, 4) - 7250 * Math.pow(val, 3) + 474375 * Math.pow(val, 2) - 343750 * val - 1125000000) / 9375000;
    } else if (color === "green") {
      r = (23 * Math.pow(val, 4) - 3850 * Math.pow(val, 3) + 203125 * Math.pow(val, 2) - 13906250 * val + 1471875000) / 9375000;
      g = (7 * Math.pow(val, 4) - 1200 * Math.pow(val, 3) + 59375 * Math.pow(val, 2) - 4218750 * val + 914062500) / 4687500;
      b = (7 * Math.pow(val, 4) - 1230 * Math.pow(val, 3) + 66125 * Math.pow(val, 2) - 3543750 * val + 277500000) / 1875000;
    }
    return "#" + lpad(Math.round(r).toString(16), "0", 2) + lpad(Math.round(g).toString(16), "0", 2) + lpad(Math.round(b).toString(16), "0", 2);
  };

}).call(this);

},{}]},{},[7])
;